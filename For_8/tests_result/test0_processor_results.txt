}
0; return

    pipe_writer); reverse(buf,
    2); - BUF_SIZE buf, read(pipe_reader,
    {0}; = buf[BUF_SIZE] char

    }
    O_WRONLY); open(PIPE2, = pipe_writer
        { -1) == (pipe_writer while

    }
    O_RDONLY); open(PIPE1, = pipe_reader
        { -1) == (pipe_reader while

    -1; = pipe_writer int
    -1; = pipe_reader int

    umask(0); (void)
    block logic second //
    { main() int

}
free(result);
    free(marks);
    free(words);

    }
    free(marks[i]);
        free(words[i]);
        { ++i) BUF_SIZE; < i 0; = i (int for

    BUF_SIZE); result, write(fd,

    }
    }
        }
            words[words_count]); strcat(result,
                { -1) > (words_count if
            }
            marks[marks_count]); strcat(result,
                { -1) > (marks_count if
            { else }
        }
            marks[marks_count]); strcat(result,
                { -1) > (marks_count if
            }
            words[words_count]); strcat(result,
                { -1) > (words_count if
            { (my_isalnum(string[0])) if
        --marks_count;
        --words_count;
        { -1) > marks_count || -1 > (words_count while
    sizeof(char)); calloc(BUF_SIZE, = *result char

    }
    }
        }
            break;
                j; = i
                '\0'; = buf[0]

                }
                buf); strcpy(marks[marks_count++],
                    { else }
                buf); strcpy(words[words_count++],
                    { (my_isalnum(string[i])) if

                '\0'; = 1] + i - buf[j
                { 1) - strlen(string) == (j if else }
            break;
                1; - j = i
                '\0'; = buf[0]

                }
                buf); strcpy(marks[marks_count++],
                    { else }
                buf); strcpy(words[words_count++],
                    { (my_isalnum(string[i])) if

                '\0'; = i] - buf[j
                { my_isalnum(string[j])) != (my_isalnum(string[i]) if
            string[j]; = i] - buf[j
            { ++j) strlen(string); < j i; = j (int for
        buf[BUF_SIZE]; char
        { ++i) strlen(string); < i 0; = i (int for
    0; = marks_count int
    0; = words_count int

    }
    sizeof(char)); calloc(BUF_SIZE, = marks[i]
        sizeof(char)); calloc(BUF_SIZE, = words[i]
        { ++i) BUF_SIZE; < i 0; = i (int for

    sizeof(char*)); calloc(BUF_SIZE, = **marks char
    sizeof(char*)); calloc(BUF_SIZE, = **words char
    { fd) int *string, reverse(char void

}
'\n'; != ch && '\t' != ch && ' ' != ch return
    { ch) my_isalnum(char int

"/home/vlad/OS/IHW1/pipe2_1.fifo" PIPE2 #define
"/home/vlad/OS/IHW1/pipe1_2.fifo" PIPE1 #define
5002 BUF_SIZE #define

<unistd.h> #include
<stdlib.h> #include
<sys/stat.h> #include
<string.h> #include
<stdio.h> #include
<fcntl.h> #include